---
title: "Analyses Online Experiments"
author: "Elena Benini"
date: "08 giugno 2020"
output: html_document
---

```{r setup, include=FALSE}

# try if this works for your, otherwise load each package with the line below
if(!require(pacman)) install.packages("pacman")
pacman::p_load("haven", "dplyr", "lme4", "reshape2", "ggplot2", "wesanderson", "afex")

select <- dplyr::select
filter <- dplyr::filter

# write the path to your project folder
setwd('C://Users//Elena//Documents//AA_PhD//Projects//BRAC01_BRAC02//BRAC01-FirstOnline')

# define paths to further subfolders in the project folders (create them first)
dataDir = "data//"
figDir = "figures//"
tabDir = "tables//"

# a .R file with custom functions - define the path to it if different from the working directory
source("C://Users//Elena//Documents//AA_PhD//Projects//expra2020_faces//modelsFun.R")
```

```{r load data}
d1 <- read.csv(paste0(dataDir, "B1_43pps", ".csv"), sep = ";", dec = ",")
d1$exp <- "BRAC1"
d1$map_horiAA300 <- 0
d1$map_horiAA300[d1$counterbalance == "horiAA_1st300"] <- 1
d2 <- read.csv(paste0(dataDir, "B2_43pps", ".csv"), sep = ";", dec = ",")
d2$map_horiAA300 <- 0
d2$map_horiAA300[d2$counterbalance == "BRAC2_horiAA_1st300"] <- 1
d2$exp <- "BRAC2"



names(d2)[names(d2) == "framecolor_R"] <- "context_R"
names(d1)[names(d1) == "cuecolor_R"] <- "context_R"
 
# d <- read.csv(paste0(dataDir, "B2_Pro1", ".csv"), sep = ";", dec = ",")
# demo <- read.csv(paste0(tabDir, "logbook_BRAC2_Pro1", ".csv"), sep = ";", dec = ",")
# d$prolific <- 1
# d1 <- read.csv(paste0(dataDir, "B2_RWTH1", ".csv"), sep = ";", dec = ",")
# demo1 <- read.csv(paste0(tabDir, "logbook_BRAC2_RWTH1", ".csv"), sep = ";", dec = ",")
# d1$prolific <- 0
# 
d <- rbind(d1, d2)
# #demo <- demo[, names(demo1)]
# demo <- rbind(demo, demo1)
# 
# 
# for (j in unique(d$pp)){
#   d[d$pp == j, "age"] <- demo[demo$pp == j, "age"]
#   d[d$pp == j, "sex"]  <- demo[demo$pp == j, "sex"]
#   d[d$pp == j, "psyKnowledge"]  <- demo[demo$pp == j, "psyKnowledge"]
#   d[d$pp == j, "education"] <- demo[demo$pp == j, "education"]
#   d[d$pp == j, "handedness"]  <- demo[demo$pp == j, "handedness"]
#   # d[d$pp == j, "handedness"]  <- demo[demo$pp == j, "response.2"]
#   d[d$pp == j, "motherTongue"]  <- demo[demo$pp == j, "motherTongue"]
#   #d[d$pp == j, "motherTongue"]  <- demo[demo$pp == j, "response.3"]
#   d[d$pp == j, "country"] <- demo[demo$pp == j, "country"]
# }
# 
# 

# 
# for (p in c("GM4", "LU1", "LY8", "NE3", "NW8", "TO3", "UG7", "WI5", "XL2", "YF1", "5896f9951a06b50001a7ff12", "5b1fc3ae325d600001c03dcb", "5d5bcd6c0802ee001608c5a8", "5e4a932344498f4e361fee0d", "5ec3dd4a21dd590667039a02")){
#   d[d$pp == p, "counterbalance"] <- "horiAA_1st300"
# }
# 
# d <- d[,-1] 
#d <- d2
# adjust class of variables
d$task_R <- as.factor(d$task_R)
d$ANSWER_R <- as.factor(d$ANSWER_R)
d[[context_R]] <- as.factor(d[[context_R]])
d$context_R <- as.factor(d$context_R)
d$Attempt <- as.factor(d$Attempt)
d$cocoa <- as.factor(d$cocoa)
d$counterbalance <- as.factor(d$counterbalance)
d$age <- as.numeric(d$age)
d$sex <- as.factor(d$sex)
d$psyKnowledge <- as.factor(d$psyKnowledge)
d$education <- as.factor(d$education)
d$handedness <- as.factor(d$handedness)
d$motherTongue <- as.factor(d$motherTongue)
d$country <- as.factor(d$country)
d$prolific <- as.factor(d$prolific)
d$map_horiAA300 <- as.factor(d$map_horiAA300)

#write.csv2(d, paste0(dataDir, "B2_43pps.csv"), row.names=FALSE)

```

```{r}
#table(d$country)

d$country[d$country == "Wales"] <- "United Kingdom"
d$country[d$country == "England"] <- "United Kingdom"
d$country[d$country == "English"] <- "United Kingdom"
d$country[d$country == "Northern Ireland"] <- "United Kingdom"
d$country[d$country == "germany"] <- "Germany"
d$country[d$country == "italy"] <- "Italy"
d$country[d$country == "Netherlands"] <- "The Netherlands"
d$country[d$country == "poland"] <- "Poland"
d$country[d$country == "Portual"] <- "Portugal"
d$country[d$country == "España"] <- "Spain"
d$country[d$country == "United States"] <- "USA"

#table(d$motherTongue)

d$motherTongue[d$motherTongue == "english"] <- "English"
d$motherTongue[d$motherTongue == "german"] <- "German"
d$motherTongue[d$motherTongue == "german"] <- "German"
d$motherTongue[d$motherTongue == "italian"] <- "Italian"
d$motherTongue[d$motherTongue == "Hungary"] <- "Hungarian"
d$motherTongue[d$motherTongue == "polish"] <- "Polish"
d$motherTongue[d$motherTongue == "portuguese"] <- "Portuguese"
d$motherTongue[d$motherTongue == "Portuguese (PT)"] <- "Portuguese"

```


```{r fix age missing values}

# estimate age using other demographics - use this to replace missing ages

# estimate model
modAge <- lm(age ~ prolific + sex + psyKnowledge + education + country, data = d)
#summary(modAge)
# predict values
d$predictedAge <- predict.lm(modAge, d)
# substitute na with the predicted - leave the other unchanged
noAgepps <- unique(d[is.na(d$age), "pp"])
for (j in noAgepps){
  d[d$pp == j, "age"] <- d[d$pp == j, "predictedAge"]
}

```

```{r}
#d <- d[d$exp == "BRAC2",]
# detect if it's brac01 or brac02 from the colour of frame and cue
if (length(unique(d$framecolor)) == 3){
  B = "B1B2"
  } else if (unique(d$framecolor)[1] == "black"){
  B = "B1"
  context = "cuecolor"
  context_R = "cuecolor_R"
  } else if (unique(d$cuecolor)[1] == "black"){
  B = "B2"
  context = "framecolor"
  context_R = "framecolor_R"
  }
print(B)
```

```{r different datsets versions}
# create a column useful afterwards
d$respRepetitions <- 0

# dataset clening for rts analyses
drt <- d[(d$task_R != 99 & d$rt > 200 & !is.na(d$Attempt == 1)),]
drt <- drt[!(drt$error == 1 | drt$error_R == 1),]

drt$logRT <- log(drt$rt)

for (j in unique(drt$pp)){
  drt[drt$pp == j, "respRepetitions"] <- sum(drt$pp == j & drt$ANSWER_R == 0)
}

# dataset cleaing for error analyses
de <- d[d$task_R != 99 & d$rt > 200,]

# count resp repetitions
for (j in unique(de$pp)){
  de[de$pp == j, "respRepetitions"] <- sum(de$pp == j & de$ANSWER_R == 0)
}

drt$respRepetitions <- as.numeric(drt$respRepetition)
de$respRepetitions <- as.numeric(de$respRepetition)
```


```{r count sw rep in each pp}
# numbers of sw and rep
repSw <- as.data.frame(unique(d$pp))
names(repSw) <- "pp"


for (var in c("task_R", "ANSWER_R", context_R)){  
  name_rep <- paste(var, "rep", sep = "")
  name_sw <- paste(var, "sw", sep = "")
  repSw[[name_rep]] <- 0
  repSw[[name_sw]] <- 0
  for (j in unique(d$pp)){
    repSw[repSw$pp == j, name_rep] <- sum(d$pp == j & d[, var] == 0)
    repSw[repSw$pp == j, name_sw] <- sum(d$pp == j & d[, var] == 1)
  }
}

#plot
repSw_long <- melt(repSw, id.vars = "pp", measure.vars = c(2:7))
repSw_long$pp <- as.factor(repSw_long$pp)

png(paste0(figDir, B, "_rep&sw", ".png"), width = 8000, height = 1500, res = 200)
ggplot(repSw_long, aes(x= pp, y = value, fill = variable)) +
  geom_col(width = 0.9, color = "black", position = position_dodge(0.9)) +
  theme_bw() +
  coord_cartesian(ylim=c(150,240)) +
  theme(axis.title = element_text(face = "bold"))
dev.off()

```

```{r RT vizs}
# drt is the datset

# average RTs per condition - relevant variables 
if (B == "B1"){
  glblRel <- group_my(drt, rt, pp, task_R, ANSWER_R, cuecolor_R, cocoa)
  condtnsRel <- group_my(glblRel, meanrt, cuecolor_R, ANSWER_R, task_R, cocoa)
  } else if (B == "B2"){
    glblRel <- group_my(drt, logRT, pp, task_R, ANSWER_R, context_R, cocoa)
    condtnsRel <- group_my(glblRel, meanlogRT, context_R, ANSWER_R, task_R, cocoa)
  #glblRel <- group_my(drt, rt, pp, task_R, ANSWER_R, framecolor_R, cocoa)
  #condtnsRel <- group_my(glblRel, meanrt, framecolor_R, ANSWER_R, task_R, cocoa)
  }

#write.csv2(condtnsRel, paste(tabDir, "rtFigValues.csv", sep = ""))

# barplot
pd = position_dodge(.7)
png(paste0(figDir, B, "_rts", ".png"), width = 1200, height = 1000, res = 200)
ggplot(condtnsRel, aes(x= task_R, y = meanmeanlogRT, fill = ANSWER_R)) +
  geom_col(width = 0.7, color = "black", position = pd) +
  geom_errorbar(aes(ymin  = meanmeanlogRT - se, ymax  = meanmeanlogRT + se), width = 0.3, size  = 0.7, position = pd,color = "black") +
  theme_bw() +
  theme(axis.title = element_text(face = "bold")) +
  coord_cartesian(ylim=c(6.25,6.75)) +
  ylab("Mean RTs") +
  xlab("Task sequence") +
  if (B == "B1"){facet_wrap(~cuecolor_R + cocoa)
  } else if (B== "B2"){facet_wrap(~framecolor_R + cocoa)
      }else{facet_wrap(~context_R + cocoa)}
dev.off()

```

```{r error vizs}

# average RTs per condition - relevant variables
if (B == "B1"){
  glblRel <- group_my(de, error, pp, task_R, ANSWER_R, cuecolor_R, cocoa)
  condtnsRel <- group_my(glblRel, meanerror, cuecolor_R, ANSWER_R, task_R, cocoa)
  } else if (B == "B2"){
  glblRel <- group_my(de, error, pp, task_R, ANSWER_R, framecolor_R, cocoa)
  condtnsRel <- group_my(glblRel, meanerror, framecolor_R, ANSWER_R, task_R, cocoa)
  } else {
  glblRel <- group_my(de, error, pp, task_R, ANSWER_R, context_R, cocoa)
  condtnsRel <- group_my(glblRel, meanerror, context_R, ANSWER_R, task_R, cocoa)
  pps <- group_my(glblRel, meanerror, pp)
  }

#write.csv2(condtnsRel, paste(tabDir, "errorFigValues.csv", sep = ""))

# barplot
pd = position_dodge(.7)
png(paste0(figDir, B, "_errors", ".png"), width = 1200, height = 1000, res = 200)
ggplot(condtnsRel, aes(x= task_R, y = meanmeanerror, fill = ANSWER_R)) +
  geom_col(width = 0.7, color = "black", position = pd) +
  geom_errorbar(aes(ymin  = meanmeanerror - se, ymax  = meanmeanerror + se), width = 0.3, size  = 0.7, position = pd,color = "black") +
  theme_bw() +
  theme(axis.title = element_text(face = "bold")) +
  ylab("Mean RTs") +
  xlab("Task sequence") +
  if (B == "B1"){facet_wrap(~cuecolor_R + cocoa)} else if (B== "B2"){facet_wrap(~framecolor_R + cocoa)}
dev.off()

```

```{r RTs dstribution}

hist(drt$rt, freq= F, col=45, main = "", xlab= "RTs values")
# abline(v= mean(drt$rt) + sd(drt$rt), col= "darkblue", lwd= 2)
# abline(v= mean(drt$rt) - sd(drt$rt), col= "darkblue", lwd= 2)
# abline(v= mean(drt$rt) + 2*sd(drt$rt), col= "darkblue", lwd= 1)
# abline(v= mean(drt$rt) - 2*sd(drt$rt), col= "darkblue", lwd= 1)
curve(dnorm(x, mean(drt$rt), sd(drt$rt)), add= T, col= 2, lwd= 2)

# try log

# much better
hist(drt$logRT, freq= F, col=45, main = "", xlab= "log RTs values")
curve(dnorm(x, mean(drt$logRT), sd(drt$logRT)), add= T, col= 2, lwd= 2)

```

```{r hierarchical structure of the data on Rts}

modLin <- lm(logRT ~ 1, data= drt)

modEmpty <- lmer(logRT ~ 1 + (1|pp), data= drt, REML=F)
summary(modEmpty)

modEmpty1 <- lmer(logRT ~ 1 + (1|pp) + (1|stimulus), data= drt, REML=F)
summary(modEmpty1)

# the pp only is better for both 1 and 2
# BetweenSubj: empty 1 is better 
anova(modEmpty1, modLin)

```


```{r model on logRTs}

if (B == "B1"){
  mod1 <- lmer(logRT ~ task_R*ANSWER_R*context_R*cocoa + (1|pp), data= drt, REML=F)
} else if (B == "B2"){
  mod1 <- lmer(logRT ~ task_R*ANSWER_R*context_R*cocoa + (1|pp), data= drt, REML=F)
} else {
  mod1 <- lmer(logRT ~ task_R*ANSWER_R*context_R*cocoa + exp + (1|pp), data= drt, REML=F)
}

summary(mod1)
#write.csv2(write_pvalues(mod1, "exp"), file= paste0(tabDir, "mod1", ".csv"))

# with control variables
if (B == "B1" | B == "B2"){
  # same model for the 2 studies
  # either country or prolific, not both
  mod2 <- lmer(logRT ~ task_R*ANSWER_R*context_R*cocoa + blockNum + age + sex + map_horiAA300 +
                 handedness + prolific + respRepetitions + (1|pp), data= drt, REML=F)
  } else{
    # block num doens't interact signifcantly with ANS*task
  mod2 <- lmer(logRT ~ task_R*ANSWER_R*context_R*cocoa*exp + blockNum + age + sex + 
                 handedness + prolific + map_horiAA300 + respRepetitions + (1|pp),
               data= drt, REML=F)
  }
summary(mod2)
anova(mod2)
write.csv2(write_pvalues(mod2, "exp"), file= paste0(tabDir, B, "_mod2", ".csv"))
```

```{r hierarchical structure on errors}

modeEmpty <- glmer(error ~ 1 + (1|pp), family="binomial", 
                   control = glmerControl(optimizer="bobyqa"), data= de )
summary(modeEmpty)

modeEmpty1 <- glmer(error ~ 1 + (1|pp) + (1|stimulus), family="binomial", 
                   control = glmerControl(optimizer="bobyqa"), data= de )
summary(modeEmpty1)

modLog <- glm(error ~ 1, family="binomial", data= de)
summary(modLog)

# BRAC1: better with pp only
# BRAC2: stimulus as random factor better
# Bewteen-subj: both pp and stim
anova(modeEmpty, modeEmpty1)

```

```{r logit mixed model}

if (B == "B1"){
  mode1 <- glm(error ~ task_R*ANSWER_R*context_R + context_R*cocoa, family="binomial", data= de)
  #mode1 <- glmer(error ~ task_R*ANSWER_R*cuecolor_R*cocoa + (1|pp), family="binomial",
  #             control=glmerControl(optimizer="bobyqa"), data= de)
} else if (B == "B2"){
  mode1 <- glmer(error ~ task_R*ANSWER_R*framecolor_R*cocoa + (1|pp) + (1|stimulus), family="binomial",
               control=glmerControl(optimizer="bobyqa"), data= de)
} else{
  # I have used only the interactions that wrre significant in RTs analyses, for computational issues
  mode1 <- glmer(error ~ task_R*ANSWER_R*context_R*cocoa*exp + (1|pp) +
                   (1|stimulus), family="binomial", control=glmerControl(optimizer="bobyqa"), data= de)
}
summary(mode1)
write.csv2(OddRatio_tab(mode1), file= paste0(tabDir, B, "_mode1", ".csv"))

# with more contorl variables

if (B == "B1"){
  mode2 <- glmer(error ~ task_R*ANSWER_R*context_R + task_R*cocoa + ANSWER_R*context_R + context_R*cocoa + 
                   + task_R*context_R + task_R*cocoa + context_R*cocoa + age + sex +
                   counterbalance + handedness + prolific + (1|pp), family="binomial",
               control=glmerControl(optimizer="bobyqa"), data= de)
} else if (B == "B2"){
  mode2 <- glmer(error ~ task_R*ANSWER_R*context_R + task_R*cocoa + ANSWER_R*context_R + context_R*cocoa + 
                   + task_R*context_R + task_R*cocoa + context_R*cocoa + age + sex +
                   counterbalance + handedness + prolific + respRepetitions + (1|pp), family="binomial",
                 control=glmerControl(optimizer="bobyqa"), data= de)
} else{
  mode2 <- glmer(error ~ task_R*ANSWER_R*exp + task*context_R + exp*context_R + cocoa*context_R + 
                   cocoa*exp + age + sex + map_horiAA300 + handedness + prolific + respRepetitions + 
                   (1|pp) + (1|stimulus), family="binomial", control=glmerControl(optimizer="bobyqa"),
                 data= de)
}

summary(mode2)
write.csv2(OddRatio_tab(mode2), file= paste0(tabDir, B, "_mode2", ".csv"))

```

